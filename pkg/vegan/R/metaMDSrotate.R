### Rotates metaMDS result so that axis one is parallel to vector 'x'
`metaMDSrotate` <-
    function(object, vec, ...) 
{
    if (!inherits(object, "metaMDS"))
        stop(gettextf("function works only with 'metaMDS' results"))
    x <- object$points
    sp <- object$species
    N <- NCOL(x)
    if (N < 2)
        stop(gettextf("needs at least 2 dimensions"))
    vec <- drop(vec)
    if (length(dim(vec)) > 1)
        stop(gettextf("function works only with univariate 'vec'"))
    if (!is.numeric(vec))
        stop(gettextf("'vec' must be numeric"))
    ## scores must be orthogonal for the next loop to work
    if (N > 2) {
        pc <- prcomp(x)
        x <- pc$x
        if (!all(is.na(sp)))
            sp <- sp %*% pc$rotation
    }
    ## envfit finds the direction cosine. We rotate first axis to
    ## 'vec' which means that we make other axes orthogonal to 'vec'
    ## one by one
    for (k in 2:N) {
        rot <- vectorfit(x[, c(1,k)], vec, permutations=0)$arrows
        rot <- drop(rot)
        ## rotation matrix [[sin theta, cos theta] [-cos theta, sin theta]]
        rot <- rbind(rot, rev(rot))
        rot[2,1] <- -rot[2,1]
        ## transpose (inverse) of the rotation matrix
        rot <- t(rot)
        ## Rotation of points and species scores
        x[, c(1,k)] <- x[, c(1,k)] %*% rot
        if (!all(is.na(sp)))
            sp[, c(1,k)] <- sp[, c(1,k)] %*% rot
    }
    ## Rotate 2..N axes to PC
    if (N > 2 && attr(object$points, "pc")) {
        pc <- prcomp(x[,-1])
        x[,-1] <- pc$x
        if (!all(is.na(sp)))
            sp[,-1] <- sp[,-1] %*% pc$rotation
    }
    ## '[] <-' retains attributes
    object$points[] <- x
    object$species[] <- sp
    attr(object$points, "pc") <- FALSE
    object
}

