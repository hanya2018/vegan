
R version 3.0.1 (2013-05-16) -- "Good Sport"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "permute"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('permute')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("allPerms")
> ### * allPerms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: allPerms
> ### Title: Complete enumeration of all possible permutations
> ### Aliases: allPerms print.allPerms summary.allPerms
> ###   print.summary.allPerms
> 
> ### ** Examples
> 
> ## allPerms can work with a vector
> vec <- c(3,4,5)
> allPerms(vec) ## free permutation
     [,1] [,2] [,3]
[1,]    1    3    2
[2,]    2    1    3
[3,]    2    3    1
[4,]    3    1    2
[5,]    3    2    1
> 
> ## enumerate all possible permutations for a more complicated
> ## design
> fac <- gl(2,6)
> ctrl <- how(within = Within(type = "grid", mirror = FALSE,
+                                     constant = TRUE,
+                                     nrow = 3, ncol = 2),
+                     plots = Plots(strata = fac))
> Nobs <- length(fac)
> numPerms(seq_len(Nobs), control = ctrl) ## 6
[1] 6
> (tmp <- allPerms(Nobs, control = ctrl, observed = TRUE))
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
[1,]    2    3    4    5    6    1    8    9   10    11    12     7
[2,]    3    4    5    6    1    2    9   10   11    12     7     8
[3,]    4    5    6    1    2    3   10   11   12     7     8     9
[4,]    5    6    1    2    3    4   11   12    7     8     9    10
[5,]    6    1    2    3    4    5   12    7    8     9    10    11
[6,]    1    2    3    4    5    6    7    8    9    10    11    12
> (tmp2 <- allPerms(Nobs, control = ctrl))
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
[1,]    2    3    4    5    6    1    8    9   10    11    12     7
[2,]    3    4    5    6    1    2    9   10   11    12     7     8
[3,]    4    5    6    1    2    3   10   11   12     7     8     9
[4,]    5    6    1    2    3    4   11   12    7     8     9    10
[5,]    6    1    2    3    4    5   12    7    8     9    10    11
> 
> ## turn on mirroring
> ctrl$within$mirror <- TRUE
> numPerms(seq_len(Nobs), control = ctrl)
[1] 12
> (tmp3 <- allPerms(Nobs, control = ctrl, observed = TRUE))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
 [1,]    2    3    4    5    6    1    8    9   10    11    12     7
 [2,]    3    4    5    6    1    2    9   10   11    12     7     8
 [3,]    4    5    6    1    2    3   10   11   12     7     8     9
 [4,]    5    6    1    2    3    4   11   12    7     8     9    10
 [5,]    6    1    2    3    4    5   12    7    8     9    10    11
 [6,]    1    2    3    4    5    6    7    8    9    10    11    12
 [7,]    1    6    5    4    3    2    7   12   11    10     9     8
 [8,]    2    1    6    5    4    3    8    7   12    11    10     9
 [9,]    3    2    1    6    5    4    9    8    7    12    11    10
[10,]    4    3    2    1    6    5   10    9    8     7    12    11
[11,]    5    4    3    2    1    6   11   10    9     8     7    12
[12,]    6    5    4    3    2    1   12   11   10     9     8     7
> (tmp4 <- allPerms(Nobs, control = ctrl))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
 [1,]    2    3    4    5    6    1    8    9   10    11    12     7
 [2,]    3    4    5    6    1    2    9   10   11    12     7     8
 [3,]    4    5    6    1    2    3   10   11   12     7     8     9
 [4,]    5    6    1    2    3    4   11   12    7     8     9    10
 [5,]    6    1    2    3    4    5   12    7    8     9    10    11
 [6,]    1    6    5    4    3    2    7   12   11    10     9     8
 [7,]    2    1    6    5    4    3    8    7   12    11    10     9
 [8,]    3    2    1    6    5    4    9    8    7    12    11    10
 [9,]    4    3    2    1    6    5   10    9    8     7    12    11
[10,]    5    4    3    2    1    6   11   10    9     8     7    12
[11,]    6    5    4    3    2    1   12   11   10     9     8     7
> 
> ## prints out details of the permutation scheme as
> ## well as the matrix of permutations
> summary(tmp3)

	Complete enumeration of permutations

Permutation Scheme:
NULL
Contains observed ordering?: Yes 

All permutations:
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
 [1,]    2    3    4    5    6    1    8    9   10    11    12     7
 [2,]    3    4    5    6    1    2    9   10   11    12     7     8
 [3,]    4    5    6    1    2    3   10   11   12     7     8     9
 [4,]    5    6    1    2    3    4   11   12    7     8     9    10
 [5,]    6    1    2    3    4    5   12    7    8     9    10    11
 [6,]    1    2    3    4    5    6    7    8    9    10    11    12
 [7,]    1    6    5    4    3    2    7   12   11    10     9     8
 [8,]    2    1    6    5    4    3    8    7   12    11    10     9
 [9,]    3    2    1    6    5    4    9    8    7    12    11    10
[10,]    4    3    2    1    6    5   10    9    8     7    12    11
[11,]    5    4    3    2    1    6   11   10    9     8     7    12
[12,]    6    5    4    3    2    1   12   11   10     9     8     7
> summary(tmp4)

	Complete enumeration of permutations

Permutation Scheme:
NULL
Contains observed ordering?: No 

All permutations:
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
 [1,]    2    3    4    5    6    1    8    9   10    11    12     7
 [2,]    3    4    5    6    1    2    9   10   11    12     7     8
 [3,]    4    5    6    1    2    3   10   11   12     7     8     9
 [4,]    5    6    1    2    3    4   11   12    7     8     9    10
 [5,]    6    1    2    3    4    5   12    7    8     9    10    11
 [6,]    1    6    5    4    3    2    7   12   11    10     9     8
 [7,]    2    1    6    5    4    3    8    7   12    11    10     9
 [8,]    3    2    1    6    5    4    9    8    7    12    11    10
 [9,]    4    3    2    1    6    5   10    9    8     7    12    11
[10,]    5    4    3    2    1    6   11   10    9     8     7    12
[11,]    6    5    4    3    2    1   12   11   10     9     8     7
> 
> 
> 
> cleanEx()
> nameEx("get-methods")
> ### * get-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get-methods
> ### Title: Extractor functions to access components of a permutation design
> ### Aliases: get-methods getBlocks getBlocks.default getBlocks.how
> ###   getBlocks.permControl getWithin getWithin.default getWithin.how
> ###   getWithin.permControl getStrata getStrata.default getStrata.how
> ###   getStrata.permControl getType getType.default getType.how
> ###   getType.permControl getMirror getMirror.default getMirror.how
> ###   getMirror.permControl getConstant getConstant.default getConstant.how
> ###   getConstant.permControl getPlots getPlots.default getPlots.how
> ###   getPlots.permControl getRow getRow.default getRow.how
> ###   getRow.permControl getCol getCol.default getCol.how
> ###   getCol.permControl getDim getDim.default getDim.how
> ###   getDim.permControl getNperm getNperm.default getNperm.how
> ###   getNperm.permControl getMaxperm getMaxperm.default getMaxperm.how
> ###   getMaxperm.permControl getComplete getComplete.default
> ###   getComplete.how getComplete.permControl
> ### Keywords: methods utils
> 
> ### ** Examples
> 
> set.seed(1234)
> 
> 
> 
> 
> cleanEx()
> nameEx("jackal")
> ### * jackal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jackal
> ### Title: Mandible lengths of male and female golden jackals
> ### Aliases: jackal
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(jackal)
> str(jackal)
'data.frame':	20 obs. of  2 variables:
 $ Length: num  120 107 110 116 114 111 113 117 114 112 ...
 $ Sex   : Factor w/ 2 levels "Male","Female": 1 1 1 1 1 1 1 1 1 1 ...
> 
> ## boxplot of mandible length vs sex
> plot(Length ~ Sex, data = jackal)
> 
> 
> 
> cleanEx()
> nameEx("nobs")
> ### * nobs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nobs-methods
> ### Title: Number of observations in a given object
> ### Aliases: nobs-methods nobs.numeric nobs.integer nobs.matrix
> ###   nobs.data.frame
> 
> ### ** Examples
> 
> ## numeric vector
> len <- sample(1:10, 1)
> v <- as.numeric(sample(1:100, len))
> len
[1] 3
> obs <- nobs(v)
> isTRUE(all.equal(len, obs))
[1] TRUE
> 
> ## integer
> len <- sample(1L:10L, 1)
> obs <- nobs(len)
> isTRUE(all.equal(len, obs))
[1] FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("numPerms")
> ### * numPerms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numPerms
> ### Title: Number of possible permutations for a given object
> ### Aliases: numPerms
> 
> ### ** Examples
> 
> ## permutation design --- see ?how
> ctrl <- how() ## defaults to freely exchangeable
> 
> ## vector
> v <- 1:10
> (obs <- nobs(v))
[1] 10
> numPerms(v, control = ctrl)
[1] 3628800
> 
> ## integer
> len <- length(v)
> (obs <- nobs(len))
[1] 1
> numPerms(len, control = ctrl)
[1] 3628800
> 
> ## new design, objects are a time series
> ctrl <- how(within = Within(type = "series"))
> numPerms(v, control = ctrl)
[1] 10
> ## number of permutations possible drastically reduced...
> ## ...turn on mirroring
> ctrl <- how(within = Within(type = "series", mirror = TRUE))
> numPerms(v, control = ctrl)
[1] 20
> 
> ## Try blocking - 2 groups of 5
> bl <- numPerms(v, control = how(blocks = gl(2,5)))
> bl
[1] 14400
> 
> ## should be same as
> pl <- numPerms(v, control = how(plots = Plots(strata = gl(2,5))))
> pl
[1] 14400
> stopifnot(all.equal(bl, pl))
> 
> 
> 
> cleanEx()
> nameEx("permCheck")
> ### * permCheck
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: check
> ### Title: Utility functions for permutation schemes
> ### Aliases: check permCheck print.check print.summary.check summary.check
> ###   permuplot
> ### Keywords: utilities design methods
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D  ##D 
> ##D ## use example data from ?pyrifos in package vegan
> ##D require(vegan)
> ##D example(pyrifos)
> ##D 
> ##D ## Demonstrate the maximum number of permutations for the pyrifos data
> ##D ## under a series of permutation schemes
> ##D 
> ##D ## no restrictions - lots of perms
> ##D CONTROL <- how(within = Within(type = "free"))
> ##D (check1 <- check(pyrifos, CONTROL))
> ##D ##summary(check1)
> ##D 
> ##D ## no strata but data are series with no mirroring, so 132 permutations
> ##D CONTROL <- how(within = Within(type = "series",
> ##D                                        mirror = FALSE))
> ##D check(pyrifos, CONTROL)
> ##D 
> ##D ## no strata but data are series with mirroring, so 264 permutations
> ##D CONTROL <- how(within = Within(type = "series",
> ##D                                        mirror = TRUE))
> ##D check(pyrifos, control = CONTROL)
> ##D 
> ##D ## unrestricted within strata
> ##D check(pyrifos, control = how(strata = ditch,
> ##D                    within = Within(type = "free")))
> ##D 
> ##D ## time series within strata, no mirroring
> ##D check(pyrifos, control = how(strata = ditch,
> ##D                    within = Within(type = "series",
> ##D                                                   mirror = FALSE)))
> ##D 
> ##D ## time series within strata, with mirroring
> ##D check(pyrifos, control = how(strata = ditch,
> ##D                    within = Within(type = "series",
> ##D                                                   mirror = TRUE)))
> ##D 
> ##D ## time series within strata, no mirroring, same permutation
> ##D ## within strata
> ##D check(pyrifos, control = how(strata = ditch,
> ##D                    within = Within(type = "series",
> ##D                                    constant = TRUE)))
> ##D 
> ##D ## time series within strata, with mirroring, same permutation
> ##D ## within strata
> ##D check(pyrifos, control = how(strata = ditch,
> ##D                    within = Within(type = "series",
> ##D                                                   mirror = TRUE,
> ##D                                                   constant = TRUE)))
> ##D 
> ##D ## permute strata
> ##D check(pyrifos, how(strata = ditch,
> ##D                                within = Within(type = "none"),
> ##D                                blocks = Blocks(type = "free")))
> ## End(Not run)
> 
> ## Not run: 
> ##D  ##D 
> ##D ## this should also also for arbitrary vectors
> ##D vec1 <- check(1:100)
> ##D vec2 <- check(1:100, how())
> ##D all.equal(vec1, vec2)
> ##D vec3 <- check(1:100, how(within = Within(type = "series")))
> ##D all.equal(100, vec3$n)
> ##D vec4 <- check(1:100, how(within =
> ##D                                      Within(type= "series",
> ##D                                                 mirror = TRUE)))
> ##D all.equal(vec4$n, 200)
> ##D 
> ##D ## enumerate all possible permutations
> ##D fac <- gl(2,6)
> ##D ctrl <- how(strata = fac,
> ##D                     within = Within(type = "grid", mirror = FALSE,
> ##D                                     constant = TRUE, nrow = 3,
> ##D                                     ncol = 2))
> ##D check(1:12, ctrl)
> ##D 
> ##D numPerms(1:12, control = ctrl)
> ##D (tmp <- allPerms(12, control = ctrl, observed = TRUE))
> ##D (tmp2 <- allPerms(12, control = ctrl))
> ##D 
> ##D ## turn on mirroring ##D 
> ##D ctrl$within$mirror <- TRUE
> ##D numPerms(1:12, control = ctrl)
> ##D (tmp3 <- allPerms(12, control = ctrl, observed = TRUE))
> ##D (tmp4 <- allPerms(12, control = ctrl))
> ##D ## prints out details of the permutation scheme as
> ##D ## well as the matrix of permutations
> ##D ##summary(tmp) ##D 
> ##D ##summary(tmp2)
> ## End(Not run)
> 
> ## Not run: 
> ##D ## different numbers of observations per level of strata
> ##D fac <- factor(rep(1:3, times = c(3,2,2)))
> ##D ## free permutations in levels of strata
> ##D numPerms(7, how(type = "free", strata = fac))
> ##D allPerms(7, how(type = "free", strata = fac))
> ##D ## series permutations in levels of strata
> ##D numPerms(7, how(type = "series", strata = fac))
> ##D allPerms(7, how(type = "series", strata = fac))
> ##D 
> ##D ## allPerms can work with a vector
> ##D vec <- c(3,4,5)
> ##D allPerms(vec)
> ##D 
> ##D ## Tests for permuplot
> ##D n <- 25
> ##D ## standard permutation designs
> ##D permuplot(n, how(type = "free"))
> ##D permuplot(n, how(type = "series"))
> ##D permuplot(n, how(type = "grid", nrow = 5, ncol = 5))
> ##D 
> ##D ## restricted perms with mirroring
> ##D permuplot(n, how(type = "series", mirror = TRUE))
> ##D permuplot(n, how(type = "grid", nrow = 5, ncol = 5,
> ##D                              mirror = TRUE))
> ##D 
> ##D ## perms within strata
> ##D fac <- gl(6, 20)
> ##D control <- how(type = "free", strata = fac)
> ##D permuplot(120, control = control, cex = 0.8)
> ##D control <- how(type = "series", strata = fac)
> ##D permuplot(120, control = control, cex = 0.8)
> ##D fac <- gl(6, 25)
> ##D control <- how(type = "grid", strata = fac,
> ##D                        nrow = 5, ncol = 5)
> ##D permuplot(150, control = control, cex = 0.8)
> ##D 
> ##D ## perms within strata with mirroring
> ##D fac <- gl(6, 20)
> ##D control <- how(type = "series", strata = fac,
> ##D                        mirror = TRUE)
> ##D permuplot(120, control = control, cex = 0.8)
> ##D fac <- gl(6, 25)
> ##D control <- how(type = "grid", strata = fac,
> ##D                        nrow = 5, ncol = 5, mirror = TRUE)
> ##D permuplot(150, control = control, cex = 0.8)
> ##D 
> ##D ## same perms within strata
> ##D fac <- gl(6, 20)
> ##D control <- how(type = "free", strata = fac,
> ##D                        constant = TRUE)
> ##D permuplot(120, control = control, cex = 0.8)
> ##D control <- how(type = "series", strata = fac,
> ##D                        constant = TRUE)
> ##D permuplot(120, control = control, cex = 0.8)
> ##D fac <- gl(6, 25)
> ##D control <- how(type = "grid", strata = fac,
> ##D                        nrow = 5, ncol = 5, constant = TRUE)
> ##D permuplot(150, control = control, cex = 0.8)
> ##D 
> ##D ## same perms within strata with mirroring
> ##D fac <- gl(6, 20)
> ##D control <- how(type = "series", strata = fac,
> ##D                        mirror = TRUE, constant = TRUE)
> ##D permuplot(120, control = control, cex = 0.8)
> ##D fac <- gl(6, 25)
> ##D control <- how(type = "grid", strata = fac,
> ##D                        nrow = 5, ncol = 5, mirror = TRUE,
> ##D                        constant = TRUE)
> ##D permuplot(150, control = control, cex = 0.8)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("shuffle-utils")
> ### * shuffle-utils
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shuffle-utils
> ### Title: Utility functions for unrestricted and restricted permutations
> ### Aliases: shuffle-utils shuffleFree shuffleGrid shuffleSeries
> ###   shuffleStrata
> ### Keywords: htest design
> 
> ### ** Examples
> 
> set.seed(3)
> 
> ## draw 1 value at random from the set 1:10
> shuffleFree(1:10, 1)
[1] 1
> 
> ## permute the series 1:10
> x <- 1:10
> shuffleSeries(x)                ## with random starting point
 [1] 10  1  2  3  4  5  6  7  8  9
> shuffleSeries(x, start = 5L)    ## known starting point
 [1]  6  7  8  9 10  1  2  3  4  5
> shuffleSeries(x, flip = TRUE)   ## random start, forced mirror
 [1]  5  6  7  8  9 10  1  2  3  4
> shuffleSeries(x, mirror = TRUE) ## random start, possibly mirror
 [1]  5  6  7  8  9 10  1  2  3  4
> 
> ## permute a grid of size 3x3
> shuffleGrid(3, 3)                      ## random starting row/col
[1] 6 4 5 9 7 8 3 1 2
> shuffleGrid(3, 3, start.row = 2,
+             start.col = 3)             ## with known row/col
[1] 3 1 2 6 4 5 9 7 8
> shuffleGrid(3, 3, flip = rep(TRUE, 2)) ## random start, forced mirror
[1] 8 9 7 2 3 1 5 6 4
> 
> 
> 
> cleanEx()
> nameEx("shuffle")
> ### * shuffle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shuffle
> ### Title: Unrestricted and restricted permutations
> ### Aliases: shuffle permute
> ### Keywords: htest design
> 
> ### ** Examples
> 
> set.seed(1234)
> 
> ## unrestricted permutations
> shuffle(20)
 [1]  3 12 11 18 14 10  1  4  8  6  7  5 20 15  2  9 17 16 19 13
> 
> ## observations represent a time series of line transect
> CTRL <- how(within = Within(type = "series"))
> shuffle(20, control = CTRL)
 [1]  8  9 10 11 12 13 14 15 16 17 18 19 20  1  2  3  4  5  6  7
> 
> ## observations represent a time series of line transect
> ## but with mirroring allowed
> CTRL <- how(within = Within(type = "series", mirror = TRUE))
> shuffle(20, control = CTRL)
 [1]  7  6  5  4  3  2  1 20 19 18 17 16 15 14 13 12 11 10  9  8
> 
> ## observations represent a spatial grid, 5rx4c
> nr <- 5
> nc <- 4
> CTRL <- how(within = Within(type = "grid", ncol = nc, nrow = nr))
> perms <- shuffle(20, control = CTRL)
> ## view the permutation as a grid
> matrix(matrix(1:20, nrow = nr, ncol = nc)[perms],
+        ncol = nc, nrow = nr)
     [,1] [,2] [,3] [,4]
[1,]    7   12   17    2
[2,]    8   13   18    3
[3,]    9   14   19    4
[4,]   10   15   20    5
[5,]    6   11   16    1
> 
> ## random permutations in presence of strata
> plots <- Plots(strata = gl(4, 5))
> CTRL <- how(plots = plots, within = Within(type = "free"))
> shuffle(20, CTRL)
 [1]  8 10  6  7  9  3  5  2  1  4 19 16 20 17 18 13 12 11 14 15
> ## as above but same random permutation within strata
> CTRL <- how(plots = plots, within = Within(type = "free",
+             constant = TRUE))
> shuffle(20, CTRL)
 [1]  8  7 10  6  9 13 12 15 11 14 18 17 20 16 19  3  2  5  1  4
> 
> ## time series within each level of block
> CTRL <- how(plots = plots, within = Within(type = "series"))
> shuffle(20, CTRL)
 [1]  5  1  2  3  4 17 18 19 20 16 14 15 11 12 13  8  9 10  6  7
> ## as above, but  with same permutation for each level
> CTRL <- how(plots = plots, within = Within(type = "series",
+             constant = TRUE))
> shuffle(20, CTRL)
 [1]  2  3  4  5  1 12 13 14 15 11 17 18 19 20 16  7  8  9 10  6
> 
> ## spatial grids within each level of block, 4 x (5r x 5c)
> nr <- 5
> nc <- 5
> nb <- 4 ## number of blocks
> plots <- Plots(gl(nb, 25))
> CTRL <- how(plots = plots,
+             within = Within(type = "grid", ncol = nc, nrow = nr))
> shuffle(100, CTRL)
  [1]   9  10   6   7   8  14  15  11  12  13  19  20  16  17  18  24  25  21
 [19]  22  23   4   5   1   2   3  83  84  85  81  82  88  89  90  86  87  93
 [37]  94  95  91  92  98  99 100  96  97  78  79  80  76  77  34  35  31  32
 [55]  33  39  40  36  37  38  44  45  41  42  43  49  50  46  47  48  29  30
 [73]  26  27  28  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75
 [91]  51  52  53  54  55  56  57  58  59  60
> ## as above, but with same permutation for each level
> CTRL <- how(plots = plots,
+             within = Within(type = "grid", ncol = nc, nrow = nr,
+                             constant = TRUE))
> shuffle(100, CTRL)
  [1]  17  18  19  20  16  22  23  24  25  21   2   3   4   5   1   7   8   9
 [19]  10   6  12  13  14  15  11  67  68  69  70  66  72  73  74  75  71  52
 [37]  53  54  55  51  57  58  59  60  56  62  63  64  65  61  92  93  94  95
 [55]  91  97  98  99 100  96  77  78  79  80  76  82  83  84  85  81  87  88
 [73]  89  90  86  42  43  44  45  41  47  48  49  50  46  27  28  29  30  26
 [91]  32  33  34  35  31  37  38  39  40  36
> 
> ## permuting levels of plots instead of observations
> CTRL <- how(plots = Plots(gl(4, 5), type = "free"),
+             within = Within(type = "none"))
> shuffle(20, CTRL)
 [1] 11 12 13 14 15  1  2  3  4  5  6  7  8  9 10 16 17 18 19 20
> ## permuting levels of plots instead of observations
> ## but plots represent a time series
> CTRL <- how(plots = Plots(gl(4, 5), type = "series"),
+             within = Within(type = "none"))
> shuffle(20, CTRL)
 [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20  1  2  3  4  5
> 
> ## permuting levels of plots but plots represent a time series
> ## free permutation within plots
> CTRL <- how(plots = Plots(gl(4, 5), type = "series"),
+             within = Within(type = "free"))
> shuffle(20, CTRL)
 [1] 15 11 14 12 13 17 16 18 20 19  5  4  2  1  3  6  7 10  9  8
> 
> ## permuting within blocks
> grp <- gl(2, 10) # 2 groups of 10 samples each
> CTRL <- how(blocks = grp)
> shuffle(length(grp), control = CTRL)
 [1]  6  5  3  7  4  1  2  8  9 10 16 20 17 14 19 12 15 18 13 11
> 
> ## Simple function using permute() to assess significance
> ## of a t.test  
> pt.test <- function(x, group, control) {
+     ## function to calculate t
+     t.statistic <- function(x, y) {
+         m <- length(x)
+         n <- length(y)
+         ## means and variances, but for speed
+         xbar <- mean(x)
+         ybar <- mean(y)
+         xvar <- var(x)
+         yvar <- var(y)
+         pooled <- sqrt(((m-1)*xvar + (n-1)*yvar) / (m+n-2))
+         (xbar - ybar) / (pooled * sqrt(1/m + 1/n))
+     }
+     ## check the control object
+     #control <- check(x, control)$control ## FIXME
+     ## number of observations
+     Nobs <- nobs(x)
+     ## group names
+     lev <- names(table(group))
+     ## vector to hold results, +1 because of observed t
+     t.permu <- numeric(length = control$nperm) + 1
+     ## calculate observed t
+     t.permu[1] <- t.statistic(x[group == lev[1]], x[group == lev[2]])
+     ## generate randomisation distribution of t
+     for(i in seq_along(t.permu)) {
+         ## return a permutation
+         want <- permute(i, Nobs, control)
+         ## calculate permuted t
+         t.permu[i+1] <- t.statistic(x[want][group == lev[1]],
+                                     x[want][group == lev[2]])
+     }
+     ## pval from permutation test
+     pval <- sum(abs(t.permu) >= abs(t.permu[1])) / (control$nperm + 1)
+     ## return value
+     return(list(t.stat = t.permu[1], pval = pval))
+ }
> 
> ## generate some data with slightly different means
> set.seed(1234)
> gr1 <- rnorm(20, mean = 9)
> gr2 <- rnorm(20, mean = 10)
> dat <- c(gr1, gr2)
> ## grouping variable
> grp <- gl(2, 20, labels = paste("Group", 1:2))
> ## create the permutation design
> control <- how(nperm = 999, within = Within(type = "free"))
> ## perform permutation t test
> perm.val <- pt.test(dat, grp, control)
> perm.val
$t.stat
[1] -2.342064

$pval
[1] 0.024

> 
> ## compare perm.val with the p-value from t.test()
> t.test(dat ~ grp, var.equal = TRUE)

	Two Sample t-test

data:  dat by grp
t = -2.3421, df = 38, p-value = 0.02452
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 -1.25582408 -0.09136416
sample estimates:
mean in group Group 1 mean in group Group 2 
             8.749336              9.422930 

> 
> 
> 
> cleanEx()
> nameEx("shuffleSet")
> ### * shuffleSet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shuffleSet
> ### Title: Generate a set of permutations from the specified design.
> ### Aliases: shuffleSet
> ### Keywords: htest design
> 
> ### ** Examples
> 
> ## simple random permutations, 5 permutations in set
> shuffleSet(n = 10, nset = 10)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    3    4    5    7    2    8    9    6   10     1
 [2,]    3    2    6   10    5    7    8    4    1     9
 [3,]   10    2    6    1    9    8    7    5    3     4
 [4,]    5    6    4    2   10    8    9    1    7     3
 [5,]    9    6    7    4    8   10    1    2    3     5
 [6,]    5    8    4    2    1    6    7    9    3    10
 [7,]   10    3    4    9    8    2    5    7    1     6
 [8,]    4    8    3    9    7    5   10    2    6     1
 [9,]    5    7    4    3   10    2    9    1    8     6
[10,]    3    1    6    7    5    4    2    8   10     9
> 
> ## series random permutations, 10 permutations in set
> shuffleSet(10, 10, how(within = Within(type = "series")))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    8    9   10    1    2    3    4    5    6     7
 [2,]    5    6    7    8    9   10    1    2    3     4
 [3,]    4    5    6    7    8    9   10    1    2     3
 [4,]    1    2    3    4    5    6    7    8    9    10
 [5,]    8    9   10    1    2    3    4    5    6     7
 [6,]    4    5    6    7    8    9   10    1    2     3
 [7,]    3    4    5    6    7    8    9   10    1     2
 [8,]    6    7    8    9   10    1    2    3    4     5
 [9,]    1    2    3    4    5    6    7    8    9    10
[10,]    7    8    9   10    1    2    3    4    5     6
> 
> ## series random permutations, 10 permutations in set,
> ## with possible mirroring
> CTRL <- how(within = Within(type = "series", mirror = TRUE))
> shuffleSet(10, 10, CTRL)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    1    2    3    4    5    6    7    8    9    10
 [2,]    4    3    2    1   10    9    8    7    6     5
 [3,]    2    1   10    9    8    7    6    5    4     3
 [4,]    8    7    6    5    4    3    2    1   10     9
 [5,]    6    7    8    9   10    1    2    3    4     5
 [6,]   10    9    8    7    6    5    4    3    2     1
 [7,]    5    4    3    2    1   10    9    8    7     6
 [8,]    8    7    6    5    4    3    2    1   10     9
 [9,]    6    5    4    3    2    1   10    9    8     7
[10,]    4    5    6    7    8    9   10    1    2     3
> 
> ## Permuting strata
> ## 4 groups of 5 observations
> CTRL <- how(within = Within(type = "none"),
+             plots = Plots(strata = gl(4,5), type = "free"))
> shuffleSet(20, 10, control = CTRL)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
 [1,]   11   12   13   14   15    1    2    3    4     5    16    17    18
 [2,]   16   17   18   19   20    6    7    8    9    10    11    12    13
 [3,]   16   17   18   19   20    6    7    8    9    10    11    12    13
 [4,]    1    2    3    4    5   16   17   18   19    20     6     7     8
 [5,]    1    2    3    4    5   11   12   13   14    15    16    17    18
 [6,]   11   12   13   14   15    6    7    8    9    10     1     2     3
 [7,]   11   12   13   14   15    1    2    3    4     5     6     7     8
 [8,]    6    7    8    9   10    1    2    3    4     5    11    12    13
 [9,]    6    7    8    9   10   11   12   13   14    15    16    17    18
[10,]    1    2    3    4    5    6    7    8    9    10    11    12    13
      [,14] [,15] [,16] [,17] [,18] [,19] [,20]
 [1,]    19    20     6     7     8     9    10
 [2,]    14    15     1     2     3     4     5
 [3,]    14    15     1     2     3     4     5
 [4,]     9    10    11    12    13    14    15
 [5,]    19    20     6     7     8     9    10
 [6,]     4     5    16    17    18    19    20
 [7,]     9    10    16    17    18    19    20
 [8,]    14    15    16    17    18    19    20
 [9,]    19    20     1     2     3     4     5
[10,]    14    15    16    17    18    19    20
> 
> ## 10 random permutations in presence of Plot-level strata
> plotStrata <- Plots(strata = gl(4,5))
> CTRL <- how(plots = plotStrata,
+             within = Within(type = "free"))
> shuffleSet(20, 10, control = CTRL)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
 [1,]   12   11   14   15   13   18   17   16   20    19     7     8     9
 [2,]    9    8    7    6   10   12   13   14   11    15    17    20    16
 [3,]   13   12   11   14   15   16   20   18   17    19     4     5     2
 [4,]   16   17   20   18   19    6    7   10    8     9    11    13    14
 [5,]   20   16   18   19   17   14   11   12   15    13     9     6    10
 [6,]   14   12   15   13   11    8    6    7   10     9     1     5     3
 [7,]    7   10    6    9    8   17   20   16   18    19     5     2     4
 [8,]    7    9    6   10    8   11   12   13   15    14     3     1     5
 [9,]   13   15   12   14   11    3    5    4    1     2    17    19    18
[10,]   14   11   13   12   15    1    5    3    2     4    19    17    18
      [,14] [,15] [,16] [,17] [,18] [,19] [,20]
 [1,]    10     6     5     1     3     2     4
 [2,]    18    19     2     1     5     3     4
 [3,]     3     1     6    10     7     9     8
 [4,]    15    12     1     5     2     4     3
 [5,]     8     7     2     1     3     4     5
 [6,]     2     4    20    19    18    16    17
 [7,]     3     1    15    11    12    14    13
 [8,]     4     2    20    16    18    17    19
 [9,]    16    20     8     7    10     6     9
[10,]    16    20     7     8     6     9    10
> ## as above but same random permutation within Plot-level strata
> CTRL <- how(plots = plotStrata,
+             within = Within(type = "free", constant = TRUE))
> shuffleSet(20, 10, CTRL)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
 [1,]   20   17   19   16   18   10    7    9    6     8    15    12    14
 [2,]   14   13   15   12   11    9    8   10    7     6     4     3     5
 [3,]   11   12   15   13   14   16   17   20   18    19     1     2     5
 [4,]   15   13   11   14   12    5    3    1    4     2    20    18    16
 [5,]    3    4    5    1    2   13   14   15   11    12     8     9    10
 [6,]   17   19   20   16   18    2    4    5    1     3    12    14    15
 [7,]    4    1    3    2    5   14   11   13   12    15     9     6     8
 [8,]    8    6    9    7   10   13   11   14   12    15     3     1     4
 [9,]   11   14   15   13   12    6    9   10    8     7     1     4     5
[10,]    8    7    9   10    6   13   12   14   15    11     3     2     4
      [,14] [,15] [,16] [,17] [,18] [,19] [,20]
 [1,]    11    13     5     2     4     1     3
 [2,]     2     1    19    18    20    17    16
 [3,]     3     4     6     7    10     8     9
 [4,]    19    17    10     8     6     9     7
 [5,]     6     7    18    19    20    16    17
 [6,]    11    13     7     9    10     6     8
 [7,]     7    10    19    16    18    17    20
 [8,]     2     5    18    16    19    17    20
 [9,]     3     2    16    19    20    18    17
[10,]     5     1    18    17    19    20    16
> 
> ## time series within each level of Plot strata
> CTRL <- how(plots = plotStrata,
+             within = Within(type = "series"))
> shuffleSet(20, 10, CTRL)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
 [1,]   15   11   12   13   14   18   19   20   16    17     6     7     8
 [2,]    7    8    9   10    6   11   12   13   14    15     2     3     4
 [3,]   19   20   16   17   18   10    6    7    8     9    11    12    13
 [4,]    2    3    4    5    1   15   11   12   13    14     6     7     8
 [5,]   11   12   13   14   15    7    8    9   10     6     2     3     4
 [6,]   20   16   17   18   19   13   14   15   11    12     5     1     2
 [7,]   10    6    7    8    9   13   14   15   11    12    20    16    17
 [8,]   19   20   16   17   18   12   13   14   15    11     6     7     8
 [9,]    7    8    9   10    6    3    4    5    1     2    11    12    13
[10,]    9   10    6    7    8   20   16   17   18    19     5     1     2
      [,14] [,15] [,16] [,17] [,18] [,19] [,20]
 [1,]     9    10     3     4     5     1     2
 [2,]     5     1    18    19    20    16    17
 [3,]    14    15     4     5     1     2     3
 [4,]     9    10    18    19    20    16    17
 [5,]     5     1    16    17    18    19    20
 [6,]     3     4     7     8     9    10     6
 [7,]    18    19     1     2     3     4     5
 [8,]     9    10     3     4     5     1     2
 [9,]    14    15    19    20    16    17    18
[10,]     3     4    11    12    13    14    15
> ## as above, but  with same permutation for each Plot-level stratum
> CTRL <- how(plots = plotStrata,
+             within = Within(type = "series", constant = TRUE))
> shuffleSet(20, 10, CTRL)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
 [1,]    6    7    8    9   10   11   12   13   14    15    16    17    18
 [2,]   14   15   11   12   13    9   10    6    7     8     4     5     1
 [3,]   18   19   20   16   17   13   14   15   11    12     8     9    10
 [4,]   18   19   20   16   17    8    9   10    6     7    13    14    15
 [5,]    9   10    6    7    8   19   20   16   17    18     4     5     1
 [6,]   16   17   18   19   20   11   12   13   14    15     1     2     3
 [7,]   18   19   20   16   17   13   14   15   11    12     3     4     5
 [8,]   19   20   16   17   18    4    5    1    2     3     9    10     6
 [9,]   12   13   14   15   11    7    8    9   10     6    17    18    19
[10,]    5    1    2    3    4   10    6    7    8     9    15    11    12
      [,14] [,15] [,16] [,17] [,18] [,19] [,20]
 [1,]    19    20     1     2     3     4     5
 [2,]     2     3    19    20    16    17    18
 [3,]     6     7     3     4     5     1     2
 [4,]    11    12     3     4     5     1     2
 [5,]     2     3    14    15    11    12    13
 [6,]     4     5     6     7     8     9    10
 [7,]     1     2     8     9    10     6     7
 [8,]     7     8    14    15    11    12    13
 [9,]    20    16     2     3     4     5     1
[10,]    13    14    20    16    17    18    19
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.14 0.02 1.163 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
